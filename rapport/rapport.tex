\documentclass[12pt]{article}

% Chargement des packages nécessaires
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{graphicx}


% Définition de la page de garde avec titre, auteurs, date

\title{Architecture des Ordinateurs : Rapport de Projet}

\author{Candice Bentéjac et Paul Beziau\\
  Licence 2 d'Informatique\\ 
  Architecture des Ordinateurs}

\date{\today}

% Début du document
\begin{document}

% Chargement page de garde
\begin{figure}
  \includegraphics{logo_ub.png}
  \end{figure}
\maketitle

% Permet de sauter 5 lignes
\vspace{5\baselineskip}
% Résumé du rapport
\abstract{Ce rapport tient lieu de compte-rendu du binôme composé de Paul Beziau et Candice Bentéjac (groupe IN400A2) dans le cadre du projet d'architecture des ordinateurs (UE Architecture des Ordinateurs).}

% Nouvelle page
\newpage

% Chargement table des matières
\tableofcontents
\newpage

\section*{Introduction}
\paragraph{}Dans le cadre de l'Unité d'Enseignement ``Architecture des Ordinateurs'' (INF 155), il nous a été demandé de réaliser un projet consistant à modifier les fichiers sources de l'architecture du processeur y86, qui est elle-même une version simplifiée de l'architecture du processeur x86, de sorte à étendre le processeur. Ces modifications devaient être effectuées tant sur la version {\itshape séquentielle} que sur la version {\itshape pipelinée} de l'architecture.

\paragraph{}Le projet était constitué de trois parties, présentées sous forme d'exercices.

\paragraph{}Le premier exercice consistait à libérer des emplacements parmi les {\itshape opcodes} y86 en factorisant des instructions les unes avec les autres. En effet, l'architecture y86 ne comprend que 16 {\itshape opcodes} et ne peut donc, par extension, coder que 16 instructions différentes. Or, dans les fichiers servant de source au projet, ces 16 emplacements étaient déjà occupés.

Il nous fallait alors libérer plusieurs de ces {\itshape opcodes} afin de pouvoir, plus tard dans l'avancement du projet, ajouter de nouvelles instructions. Les factorisations que nous avons effectuées se traduisent par un regroupement de plusieurs instructions présentant des analogies sous le même {\itshape opcode}.

\paragraph{}Le deuxième exercice avait pour but de nous faire modifier l'architecture du processeur afin que cette dernière soit capable de supporter des instructions s'exécutant sur plusieurs cycles, c'est-à-dire des instructions qui sont équivalentes à des enchaînements de plusieurs ``sous-instructions''.

A titre d'exemple, on peut parler de l'instruction du processeur x86 \verb+enter+ (décrite dans le sujet du projet) qui est équivalente à \verb+push %ebp+ suivi de \verb+rrmovl+\\ \verb+%esp,%ebp+.

\paragraph{}Enfin, le troisième exercice nous demandait d'ajouter plusieurs instructions à l'architecture, telle que l'instruction \verb+enter+ précitée. Cet exercice étant dans la continuité du précédent, les instructions à ajouter étaient précisément des instructions s'exécutant sur plusieurs cycles.

\paragraph{}Ce rapport est le compte-rendu du travail sur le projet que notre binôme, constitué de Paul Beziau et de Candice Bentéjac (groupe IN400 A2), a effectué.




\section{Exercice 1 : De la place dans les opcodes}
\paragraph{}Le but de l'exercice était de libérer des {\itshape opcodes}, plus particulièrement les {\itshape opcodes} \verb+I_ALUI+ et \verb+I_IRMOVL+, en factorisant les instructions qui en dépendaient avec des instructions similaires qui dépendaient d'autres {\itshape opcodes}.

\subsection{Factorisation de iaddl etc. avec addl etc.}
\paragraph{}Dans un premier temps, il nous a été demandé de libérer l'{\itshape opcode} \verb+I_ALUI+ en factorisant les instructions l'utilisant avec celles utilisant l'{\itshape opcode} \verb+I_OPL+.

\paragraph{}Nous avons commencé par supprimer l'{\itshape opcode} \verb+I_ALUI+ comme cela était indiqué dans le sujet du projet. Les instructions utilisant auparavant l'{\itshape opcode} \verb+I_ALUI+ (et par extension, l'\verb+icode IOPL+) étant désormais confondues avec celles dépendant de l'{\itshape opcode} \verb+I_ALU+ (\verb+icode OPL+), il nous fallait alors les distinguer.

\paragraph{}Avant même de modifier les versions séquentielle et pipelinée de l'architecture, nous avons créé un fichier de test qui effectuait dans un premier temps un \verb+addl+ puis un \verb+iaddl+. L'exécuter avant d'effectuer toute modification de l'architecture via les fichiers HCL nous a permis de remarquer que les instructions de type \verb+iopl+ étaient codées sur un nombre d'octects différent de celui sur lequel étaient codées les instructions de type \verb+opl+ (6 octects pour les \verb+iopl+ contre seulement 2 pour les \verb+opl+).

Pour éviter des problèmes futurs, nous avons harmonisé le nombre d'octets sur lequel étaient codés les deux types d'instructions en passant celui des \verb+opl+ à 2 (pour ce faire, nous avons directement modifié le tableau des instructions présent dans le fichier \verb+misc/isa.c+).

\paragraph{}Cela fait, nous avons modifié le fichier HCL de la version séquentielle en supprimant les opérandes \verb+IOPL+ à chaque fois qu'ils étaient accolés à des opérandes \verb+OPL+ afin d'éviter des doublons. En effet, leur {\itshape opcode} étant désormais identique, avoir un \verb+IOPL+ au même endroit qu'un \verb+OPL+ revenait à avoir 2 fois un \verb+OPL+.

\paragraph{}Pour différencier une instruction \verb+iopl+ d'une instruction \verb+opl+, nous avons utilisé le chargement d'un registre en source A de l'ALU comme critère puisqu'une instruction \verb+opl+ prend en paramètre deux registres, tandis qu'\verb+iopl+ prend une constante et un registre. Ainsi, il faut indiquer au processeur que, durant la phase \verb+Execute+, si l'instruction utilise l'\verb+icode OPL+ et n'a préalablement pas chargé de registre en tant que source A (c'est-à-dire que \verb+rA+ est égal à \verb+RNONE+), alors on charge une constante en tant que source A de l'ALU.

\paragraph{}On renvoie donc \verb+valC+ (qui correspond à une constante) plutôt que \verb+valA+ (qui correspond à un registre). Puisque le processeur n'est qu'un ensemble de \verb+if+/\verb+else+, \verb+valA+ ne sera renvoyé que si la condition ``pas de registre chargé en source A durant la phase \verb+Decode+'' est fausse.

\paragraph{}Nous avons modifié la version pipelinée de l'architecture de la même façon : après avoir supprimé les ``doublons'' \verb+IOPL+, nous avons modifié la phase \verb+Execute+ du processeur (au moment du chargement des sources de l'ALU) de sorte à ce qu'il teste si un registre n'a pas été chargé en tant que source A lors de la phase \verb+Decode+ (c'est-à-dire qu'il teste si \verb+E_srcA+ égale \verb+RNONE+). Le cas échéant, le processeur utilisera \verb+E_valC+ comme source de A de l'ALU ; sinon, il utilisera \verb+E_valA+.



\subsection{Factorisation de irmovl avec rrmovl}
\paragraph{}La deuxième partie de l'exercice nous demandait de libérer cette fois-ci l'{\itshape opcode} \verb+I_IRMOVL+ et de factoriser son instruction avec celle de l'{\itshape opcode} \verb+I_RRMOVL+.

\paragraph{}La factorisation de \verb+irmovl+ avec \verb+rrmovl+ s'est faite de la même manière que celle de \verb+iopl+ avec \verb+opl+. Nous avons dû à nouveau libérer un {\itshape opcode} (ici, \verb+I_IRMOVL+) puis  éditer le fichier \verb+misc/isa.c+ pour que l'instruction \verb+rrmovl+, normalement codée sur 2 bits, soit désormais codée sur 6 bits, à l'image de l'instruction \verb+irmovl+.

\paragraph{}L'édition des fichiers HCL des versions séquentielle et pipelinée a également été strictement identique à celle effectuée pour la factorisation d'\verb+iopl+ avec \verb+opl+, à la différence près que l'\verb+icode+ testé était bien entendu \verb+rrmovl+ plutôt que \verb+opl+.



\subsection{Factorisation de push, pop, call, ret (bonus)}
\paragraph{}La question bonus de l'exercice 1 nous demander d'étudier les instructions \verb+push+, \verb+pop+, \verb+call+ et \verb+ret+, relativement proches les unes des autres, et de déterminer s'il était intéressant de les factoriser par couples \verb+push/pop | call/ret+, \verb+push/call | pop/ret+ ou encore par quadruplet \verb+push/pop/call/ret+.

\paragraph{}Il nous a, dès le départ, semblé évident que l'option la plus intéressante était la factorisation par quadruplet. Cette dernière permettait en effet de rassembler quatre instructions sous la bannière d'un unique {\itshape opcode}, ce qui aurait alors engendré la libération de 3 {\itshape opcodes}. Néanmoins, la factorisation directe des 4 instructions nous paraissait fastidieuse. C'est pour cette raison que nous avons décidé de procéder en deux temps : nous allions d'abord factoriser par couples, et une fois cette factorisation faite, nous pourrions factoriser par quadruplet.

\paragraph{}Pour déterminer quelle combinaison de couples (\verb+push/pop | call/ret+ ou \verb+push/call | pop/ret+) était la plus intéressante à utiliser, nous avons tout simplement étudié l'architecture séquentielle du processeur et effectué un comptage manuel des occurrences de chaque couple. Il est alors apparu que les couples qui revenaient le plus fréquemment étaient \verb+push/call+ et \verb+pop/ret+. Nous avons conséquemment décidé de factoriser les instructions suivant ce schéma.

\paragraph{}Nous avons libéré deux {\itshape opcodes} (\verb+I_CALL+ et \verb+I_RET+, que nous avons respectivement renommés \verb+I_FREE3+ et \verb+I_FREE4+) comme nous l'avions fait lors des questions précédentes. En examinant plus attentivement le code de \verb+misc/isa.h+, nous avons remarqué plusieurs énumérations (marquées par des \verb+enum+) qui contenaient des instructions différentes pour un même {\itshape opcode}. Il y avait par exemple une énumération pour les différentes conditions de l'{\itshape opcode} \verb+I_JUMP+, ou pour les différentes opérations que pouvait effectuer l'ALU. 

\paragraph{}Comprenant que ces énumérations correspondaient à des états différents de l'\verb+ifun+ pour un même \verb+icode+, nous avons jugé pertinent de créer deux énumérations supplémentaires, une pour le couple \verb+push/call+ et l'autre pour le couple \verb+pop/ret+, ce qui a conduit à l'ajout suivant :
\begin{quote}
\begin{verbatim}
typedef enum { J_PUSH, J_CALL } push_t;
typedef enum { J_POP, J_RET } pop_t;
\end{verbatim}
\end{quote}
Dans \verb+misc/isa.c+, nous avons également modifié le nombre d'octets sur lequel étaient codées les instructions. Ainsi, \verb+push+ et \verb+call+ sont passées à 6 octets (initialement codées sur 2 et 5 octets) tandis que \verb+pop+ et \verb+ret+ sont passées à 2 octets (initialement codées sur 2 et 1 octets).

\paragraph{}IMPLEMENTATION SEQ

\paragraph{}IMPLEMENTATION QUADRUPLET (ENUM + TAB A 6)

\paragraph{}IMPLEMENTATION PIPE


\section{Exercice 2}



\section{Exercice 3}
\subsection{Instruction enter}

\subsection{Instruction mul}


\section*{Conclusion}

\end{document}
